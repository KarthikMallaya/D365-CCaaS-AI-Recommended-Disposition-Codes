// ==========================================================
// Disposition Code Copilot - Form Handler v2.1
// OPTIMIZED FOR HIGH-VOLUME CONTACT CENTERS
// ==========================================================
// Web resources:
//  - JS:   ccaasfde_dispositioncodecopilotformhandler
//  - Custom Page: ccaasfde_dispositionrecommendation_d051d
//
// Trigger:
//  - CIF "EndConversationEvent" (fires when conversation ends)
// Action:
//  - On form load: parallel fetch workstream + dispositions (non-blocking)
//  - On end: open modal with pre-cached data (instant)
//
// v2.1 CHANGE LOG:
//  - FIX: Added sessionStorage guard to prevent duplicate modal when
//    agent closes conversation form/tab (EndConversationEvent fires
//    on both conversation end AND session close, and in-memory guards
//    are lost on form reload). sessionStorage persists across form
//    reloads within the same browser session.
//  - All other logic is UNCHANGED from v2.0.
// ==========================================================

"use strict";

// ===== CONFIGURATION =====
const CONFIG = Object.freeze({
  // Entities
  DISPOSITION_ENTITY: "msdyn_ocdispositioncode",
  DISPOSITION_ID_FIELD: "msdyn_ocdispositioncodeid",
  DISPOSITION_NAME_FIELD: "msdyn_dispositioncodevalue",
  DISPOSITION_CODE_FIELD: "msdyn_name",
  
  LIVEWORKITEM_ENTITY: "msdyn_ocliveworkitem",
  WORKSTREAM_LOOKUP: "_msdyn_liveworkstreamid_value",
  
  // UI
  MODAL_CUSTOM_PAGE: "ccaasfde_dispositionrecommendation_d051d",
  CIF_END_CONVERSATION_EVENT: "EndConversationEvent",
  
  // Cache
  DISPOSITION_CACHE_TTL_MS: 5 * 60 * 1000,  // 5 minutes - dispositions rarely change
  WORKSTREAM_CACHE_TTL_MS: 30 * 60 * 1000,  // 30 minutes - workstream even more stable
  
  // Session storage key prefix for duplicate modal prevention (v2.1)
  SESSION_STORAGE_PREFIX: "ccaasfde_dispo_handled_",
  SESSION_STORAGE_TTL_MS: 30 * 60 * 1000,   // 30 minutes - generous TTL for session storage entries
  
  // Debug
  DEBUG_PREFIX: "[ccaasfde dispo v2.1]",
  VERSION: "2.1.0-2026-02-15"
});

// ===== GLOBAL CACHE (shared across all form instances) =====
// This is critical for high-volume: agents handle multiple conversations
// and we don't want to re-fetch the same data for each session
const GlobalCache = {
  // Disposition codes by workstream ID (or "global" for all-workstream codes)
  // Structure: { [workstreamId]: { data: [...], timestamp: Date.now(), promise: null } }
  dispositions: new Map(),
  
  // Workstream ID by conversation/liveworkitem ID
  // Structure: { [lwiId]: { workstreamId: "...", timestamp: Date.now() } }
  workstreams: new Map(),
  
  // In-flight promises for deduplication
  // Prevents multiple concurrent requests for the same resource
  pendingRequests: new Map(),
  
  // Check if cache entry is valid
  isValid(entry, ttlMs) {
    return entry && (Date.now() - entry.timestamp) < ttlMs;
  },
  
  // Clear expired entries (call periodically or on low memory)
  cleanup() {
    const now = Date.now();
    for (const [key, entry] of this.dispositions) {
      if (now - entry.timestamp > CONFIG.DISPOSITION_CACHE_TTL_MS * 2) {
        this.dispositions.delete(key);
      }
    }
    for (const [key, entry] of this.workstreams) {
      if (now - entry.timestamp > CONFIG.WORKSTREAM_CACHE_TTL_MS * 2) {
        this.workstreams.delete(key);
      }
    }
  }
};

// Cleanup every 10 minutes
setInterval(() => GlobalCache.cleanup(), 10 * 60 * 1000);

// ===== LOGGING =====
const log = {
  debug: (msg, data) => {
    try { console.log(CONFIG.DEBUG_PREFIX, msg, data ?? ""); } catch {}
  },
  warn: (msg, data) => {
    try { console.warn(CONFIG.DEBUG_PREFIX, msg, data ?? ""); } catch {}
  },
  error: (msg, data) => {
    try { console.error(CONFIG.DEBUG_PREFIX, msg, data ?? ""); } catch {}
  },
  perf: (label, startTime) => {
    try { console.log(CONFIG.DEBUG_PREFIX, `⏱ ${label}: ${Date.now() - startTime}ms`); } catch {}
  }
};

// ===== UTILITY FUNCTIONS =====
const Utils = {
  sleep: (ms) => new Promise(resolve => setTimeout(resolve, ms)),
  
  cleanGuid: (id) => (id || "").replace(/[{}]/g, "").toLowerCase(),
  
  formatGuidForOData: (id) => {
    if (!id) return "";
    const clean = Utils.cleanGuid(id);
    return clean.startsWith("guid'") ? clean : clean;  // Modern Dataverse doesn't need guid'' wrapper
  },
  
  // Deduplicated async operation - prevents duplicate concurrent requests
  async dedupedAsync(cacheKey, asyncFn) {
    // If there's already a pending request for this key, return that promise
    if (GlobalCache.pendingRequests.has(cacheKey)) {
      log.debug("dedupe hit", { cacheKey });
      return GlobalCache.pendingRequests.get(cacheKey);
    }
    
    // Create new promise and store it
    const promise = asyncFn().finally(() => {
      GlobalCache.pendingRequests.delete(cacheKey);
    });
    
    GlobalCache.pendingRequests.set(cacheKey, promise);
    return promise;
  },
  
  // Timeout wrapper with AbortController support
  async withTimeout(promise, ms, label = "timeout") {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), ms);
    
    try {
      const result = await Promise.race([
        promise,
        new Promise((_, reject) => {
          controller.signal.addEventListener("abort", () => {
            reject(new Error(`${label} (${ms}ms)`));
          });
        })
      ]);
      clearTimeout(timeoutId);
      return result;
    } catch (e) {
      clearTimeout(timeoutId);
      throw e;
    }
  }
};

// ===== SESSION STORAGE GUARD (v2.1) =====
// Persists across form reloads within the same browser session.
// Prevents the duplicate modal when agent closes the conversation form/tab.
const SessionGuard = {
  // Check if this conversation was already prompted for disposition
  isHandled(conversationId) {
    if (!conversationId) return false;
    try {
      const key = CONFIG.SESSION_STORAGE_PREFIX + conversationId;
      const val = sessionStorage.getItem(key);
      if (!val) return false;
      
      // Check if the stored timestamp is still within TTL
      const storedTime = parseInt(val, 10);
      if (isNaN(storedTime)) return false;
      
      if ((Date.now() - storedTime) > CONFIG.SESSION_STORAGE_TTL_MS) {
        // Expired - clean it up
        sessionStorage.removeItem(key);
        return false;
      }
      
      return true;
    } catch {
      // sessionStorage not available - fall through to existing in-memory guards
      return false;
    }
  },
  
  // Mark this conversation as handled
  markHandled(conversationId) {
    if (!conversationId) return;
    try {
      const key = CONFIG.SESSION_STORAGE_PREFIX + conversationId;
      sessionStorage.setItem(key, Date.now().toString());
    } catch {
      // sessionStorage not available - no-op, in-memory guards still work
    }
  },
  
  // Remove the handled mark (e.g., if modal was cancelled and we want to allow retry)
  unmark(conversationId) {
    if (!conversationId) return;
    try {
      sessionStorage.removeItem(CONFIG.SESSION_STORAGE_PREFIX + conversationId);
    } catch {}
  }
};

// ===== DATA FETCHING =====
const DataService = {
  
  // Get workstream ID from live work item - with caching
  async getWorkstreamId(lwiId) {
    const cleanId = Utils.cleanGuid(lwiId);
    if (!cleanId) return null;
    
    // Check cache first
    const cached = GlobalCache.workstreams.get(cleanId);
    if (GlobalCache.isValid(cached, CONFIG.WORKSTREAM_CACHE_TTL_MS)) {
      log.debug("workstream cache hit", { lwiId: cleanId, workstreamId: cached.workstreamId });
      return cached.workstreamId;
    }
    
    // Fetch with deduplication
    return Utils.dedupedAsync(`ws_${cleanId}`, async () => {
      const startTime = Date.now();
      try {
        const res = await Xrm.WebApi.retrieveRecord(
          CONFIG.LIVEWORKITEM_ENTITY,
          cleanId,
          `?$select=${CONFIG.WORKSTREAM_LOOKUP}`
        );
        
        const workstreamId = Utils.cleanGuid(res?.[CONFIG.WORKSTREAM_LOOKUP]);
        
        // Cache the result
        if (workstreamId) {
          GlobalCache.workstreams.set(cleanId, {
            workstreamId,
            timestamp: Date.now()
          });
        }
        
        log.perf("getWorkstreamId", startTime);
        log.debug("workstream resolved", { lwiId: cleanId, workstreamId });
        return workstreamId;
        
      } catch (e) {
        log.error("getWorkstreamId failed", { lwiId: cleanId, error: e?.message });
        return null;
      }
    });
  },
  
  // Get disposition codes - with caching and workstream filtering
  // Priority: 1) Workstream-specific, 2) Global (appliestoallworkstreams), 3) All active
  async getDispositions(workstreamId = null) {
    const cacheKey = workstreamId ? Utils.cleanGuid(workstreamId) : "global";
    
    // Check cache first
    const cached = GlobalCache.dispositions.get(cacheKey);
    if (GlobalCache.isValid(cached, CONFIG.DISPOSITION_CACHE_TTL_MS)) {
      log.debug("disposition cache hit", { cacheKey, count: cached.data.length });
      return cached.data;
    }
    
    // Fetch with deduplication
    return Utils.dedupedAsync(`dispo_${cacheKey}`, async () => {
      const startTime = Date.now();
      
      let dispositions = [];
      
      // Strategy 1: Try workstream-specific first
      if (workstreamId) {
        dispositions = await this._fetchWorkstreamDispositions(workstreamId);
        log.debug("workstream dispositions", { workstreamId, count: dispositions.length });
      }
      
      // Strategy 2: If no workstream-specific, get global (appliestoallworkstreams = true)
      if (dispositions.length === 0) {
        dispositions = await this._fetchGlobalDispositions();
        log.debug("global dispositions", { count: dispositions.length });
      }
      
      // Strategy 3: Ultimate fallback - all active dispositions
      if (dispositions.length === 0) {
        dispositions = await this._fetchAllDispositions();
        log.debug("all dispositions fallback", { count: dispositions.length });
      }
      
      // Cache the result
      GlobalCache.dispositions.set(cacheKey, {
        data: dispositions,
        timestamp: Date.now()
      });
      
      log.perf("getDispositions", startTime);
      log.debug("dispositions loaded", { cacheKey, count: dispositions.length });
      return dispositions;
    });
  },
  
  // Fetch dispositions linked to a specific workstream via N:N intersect table
  // Table: msdyn_ocdispositioncode_msdyn_liveworkstream
  // Columns: msdyn_ocdispositioncodeid, msdyn_liveworkstreamid
  async _fetchWorkstreamDispositions(workstreamId) {
    const cleanId = Utils.cleanGuid(workstreamId);
    
    // Query the N:N intersect table directly, then expand to get disposition details
    // This is the most efficient approach for N:N relationships
    const fetchXml = `
      <fetch top="500" distinct="true">
        <entity name="msdyn_ocdispositioncode">
          <attribute name="msdyn_ocdispositioncodeid" />
          <attribute name="msdyn_name" />
          <attribute name="msdyn_dispositioncodevalue" />
          <attribute name="msdyn_dispositioncodecategoryid" />
          <attribute name="statecode" />
          <filter>
            <condition attribute="statecode" operator="eq" value="0" />
          </filter>
          <link-entity name="msdyn_ocdispositioncode_msdyn_liveworkstream" from="msdyn_ocdispositioncodeid" to="msdyn_ocdispositioncodeid" intersect="true">
            <filter>
              <condition attribute="msdyn_liveworkstreamid" operator="eq" value="${cleanId}" />
            </filter>
          </link-entity>
          <order attribute="msdyn_dispositioncodevalue" />
        </entity>
      </fetch>
    `.trim();
    
    try {
      const encodedFetch = encodeURIComponent(fetchXml);
      const res = await Xrm.WebApi.retrieveMultipleRecords(
        CONFIG.DISPOSITION_ENTITY,
        `?fetchXml=${encodedFetch}`
      );
      
      return (res?.entities || []).map(d => ({
        id: d.msdyn_ocdispositioncodeid,
        label: d.msdyn_dispositioncodevalue || "",
        code: d.msdyn_name || "",
        categoryId: d._msdyn_dispositioncodecategoryid_value || null,
        source: "workstream"
      }));
      
    } catch (e) {
      log.warn("workstream dispositions fetch failed, will use global", { error: e?.message });
      return [];
    }
  },
  
  // Fetch all global disposition codes (applies to all workstreams)
  // Uses msdyn_appliestoallworkstreams = true filter
  async _fetchGlobalDispositions() {
    try {
      const query = 
        `?$select=msdyn_ocdispositioncodeid,msdyn_name,msdyn_dispositioncodevalue,_msdyn_dispositioncodecategoryid_value` +
        `&$filter=statecode eq 0 and msdyn_appliestoallworkstreams eq true` +
        `&$orderby=msdyn_dispositioncodevalue asc` +
        `&$top=500`;
      
      const res = await Xrm.WebApi.retrieveMultipleRecords(CONFIG.DISPOSITION_ENTITY, query);
      
      return (res?.entities || []).map(d => ({
        id: d.msdyn_ocdispositioncodeid,
        label: d.msdyn_dispositioncodevalue || "",
        code: d.msdyn_name || "",
        categoryId: d._msdyn_dispositioncodecategoryid_value || null,
        source: "global"
      }));
      
    } catch (e) {
      log.error("global dispositions fetch failed", { error: e?.message });
      return [];
    }
  },
  
  // Fetch ALL active disposition codes (fallback when no workstream-specific or global)
  async _fetchAllDispositions() {
    try {
      const query = 
        `?$select=msdyn_ocdispositioncodeid,msdyn_name,msdyn_dispositioncodevalue,_msdyn_dispositioncodecategoryid_value` +
        `&$filter=statecode eq 0` +
        `&$orderby=msdyn_dispositioncodevalue asc` +
        `&$top=500`;
      
      const res = await Xrm.WebApi.retrieveMultipleRecords(CONFIG.DISPOSITION_ENTITY, query);
      
      return (res?.entities || []).map(d => ({
        id: d.msdyn_ocdispositioncodeid,
        label: d.msdyn_dispositioncodevalue || "",
        code: d.msdyn_name || "",
        categoryId: d._msdyn_dispositioncodecategoryid_value || null,
        source: "all"
      }));
      
    } catch (e) {
      log.error("all dispositions fetch failed", { error: e?.message });
      return [];
    }
  },
  
  // NOTE: Copilot summary is fetched by the Custom Page, not JS
  // This keeps JS completely non-blocking
  
  // Save the agent's selected disposition to the conversation
  // Creates a record in msdyn_conversationdispositioncodemap
  // Schema: https://learn.microsoft.com/en-us/dynamics365/developer/reference/entities/msdyn_conversationdispositioncodemap
  // 
  // Required fields:
  //   - msdyn_dispositioncodevalue (String, max 200)
  //   - msdyn_ocliveworkitemid (Lookup to msdyn_ocliveworkitem via activityid)
  // Optional fields:
  //   - msdyn_name (String, max 100)
  //   - msdyn_ocdispositioncodeid (Lookup to msdyn_ocdispositioncode)
  //
  async saveDisposition(lwiId, dispositionId, dispositionValue) {
    const cleanLwiId = Utils.cleanGuid(lwiId);
    const cleanDispoId = dispositionId ? Utils.cleanGuid(dispositionId) : null;
    
    if (!cleanLwiId || !dispositionValue) {
      log.error("saveDisposition: missing required params", { lwiId, dispositionValue });
      return { success: false, error: "Missing required parameters" };
    }
    
    log.debug("saveDisposition called", { lwiId: cleanLwiId, dispositionId: cleanDispoId, value: dispositionValue });
    
    try {
      // Build the record for Conversation Disposition Code Map table
      // EntitySetName: msdyn_conversationdispositioncodemaps
      const record = {
        // Required: Disposition code value (max 200 chars)
        "msdyn_dispositioncodevalue": dispositionValue.substring(0, 200),
        // Optional: Name field (max 100 chars)
        "msdyn_name": dispositionValue.substring(0, 100),
        // Required: Link to the Live Work Item (Conversation)
        // The lookup references msdyn_ocliveworkitem.activityid
        "msdyn_ocliveworkitemid@odata.bind": `/msdyn_ocliveworkitems(${cleanLwiId})`
      };
      
      // Optional: Link to the OC Disposition Code if we have the ID
      if (cleanDispoId) {
        record["msdyn_ocdispositioncodeid@odata.bind"] = `/msdyn_ocdispositioncodes(${cleanDispoId})`;
      }
      
      log.debug("creating record", { entity: "msdyn_conversationdispositioncodemap", record });
      
      const result = await Xrm.WebApi.createRecord("msdyn_conversationdispositioncodemap", record);
      
      log.debug("disposition saved successfully", { 
        lwiId: cleanLwiId, 
        dispositionId: cleanDispoId,
        mapId: result.id 
      });
      
      return { success: true, id: result.id };
      
    } catch (e) {
      log.error("saveDisposition failed", { 
        error: e?.message, 
        lwiId: cleanLwiId, 
        dispositionId: cleanDispoId,
        stack: e?.stack 
      });
      return { success: false, error: e?.message };
    }
  },
  
  // Fetch disposition categories (for grouping in UI)
  async getDispositionCategories() {
    try {
      const query = 
        `?$select=msdyn_dispositioncodecategoryid,msdyn_categoryname` +
        `&$filter=statecode eq 0` +
        `&$orderby=msdyn_categoryname asc`;
      
      const res = await Xrm.WebApi.retrieveMultipleRecords("msdyn_dispositioncodecategory", query);
      
      return (res?.entities || []).map(c => ({
        id: c.msdyn_dispositioncodecategoryid,
        name: c.msdyn_categoryname || ""
      }));
      
    } catch (e) {
      log.warn("getDispositionCategories failed", { error: e?.message });
      return [];
    }
  }
};

// ===== FORM STATE MANAGER =====
// Per-form instance state (not global - each form has its own lifecycle)
class FormState {
  constructor(formContext) {
    this.formContext = formContext;
    this.conversationId = null;
    this.workstreamId = null;
    this.dispositions = [];
    this.isInitialized = false;
    this.isLoading = false;
    this.cifHandlerId = null;
    this.modalOpened = false;
    this.initPromise = null;
  }
  
  // Initialize all data in parallel - non-blocking
  async initialize() {
    if (this.isInitialized || this.isLoading) {
      return this.initPromise;
    }
    
    this.isLoading = true;
    const startTime = Date.now();
    
    this.initPromise = (async () => {
      try {
        // Get conversation ID from form
        this.conversationId = Utils.cleanGuid(this.formContext.data.entity.getId());
        
        if (!this.conversationId) {
          log.warn("no conversation ID on form");
          return;
        }
        
        // PARALLEL FETCH: workstream ID and global dispositions simultaneously
        // This is the key optimization - we don't wait for workstream before fetching dispositions
        const [workstreamId, globalDispositions] = await Promise.all([
          DataService.getWorkstreamId(this.conversationId),
          DataService.getDispositions(null)  // Start with global while we resolve workstream
        ]);
        
        this.workstreamId = workstreamId;
        
        // If we got a workstream, fetch workstream-specific dispositions
        // (may already be cached from another session with same workstream)
        if (workstreamId) {
          const wsDispositions = await DataService.getDispositions(workstreamId);
          // Use workstream-specific if available, otherwise fall back to global
          this.dispositions = wsDispositions.length > 0 ? wsDispositions : globalDispositions;
        } else {
          this.dispositions = globalDispositions;
        }
        
        this.isInitialized = true;
        log.perf("form state initialized", startTime);
        log.debug("form ready", {
          conversationId: this.conversationId,
          workstreamId: this.workstreamId,
          dispositionCount: this.dispositions.length
        });
        
      } catch (e) {
        log.error("form state init failed", { error: e?.message });
      } finally {
        this.isLoading = false;
      }
    })();
    
    return this.initPromise;
  }
  
  // Ensure data is ready (used before opening modal)
  async ensureReady() {
    if (!this.isInitialized && !this.isLoading) {
      await this.initialize();
    } else if (this.isLoading) {
      await this.initPromise;
    }
    return this.isInitialized;
  }
}

// Store FormState instances by form ID
const formStates = new WeakMap();

function getFormState(formContext) {
  if (!formStates.has(formContext)) {
    formStates.set(formContext, new FormState(formContext));
  }
  return formStates.get(formContext);
}

// ===== CIF EVENT HANDLING =====
const CIFHandler = {
  // Track if we've already handled this conversation end globally
  _handledConversations: new Set(),
  
  // Register for end conversation event
  register(formContext) {
    if (!(window.Microsoft?.CIFramework)) {
      log.debug("CIF not available");
      return;
    }
    
    const state = getFormState(formContext);
    if (state.cifHandlerId) return;  // Already registered
    
    state.cifHandlerId = window.Microsoft.CIFramework.addHandler(
      CONFIG.CIF_END_CONVERSATION_EVENT,
      async (eventData) => {
        try {
          await this.handleEndConversation(formContext, eventData);
        } catch (e) {
          log.error("CIF handler error", { error: e?.message });
        }
      }
    );
    
    log.debug("CIF handler registered", { handlerId: state.cifHandlerId });
  },
  
  // Handle conversation end event
  async handleEndConversation(formContext, eventData) {
    const state = getFormState(formContext);
    
    // Prevent duplicate modal opens for this form instance
    if (state.modalOpened) {
      log.debug("modal already opened for this form instance, skipping");
      return;
    }
    
    // Validate this event is for our conversation
    const eventLwi = this._getLwiFromEvent(eventData);
    if (eventLwi && state.conversationId && 
        Utils.cleanGuid(eventLwi) !== state.conversationId) {
      log.debug("ignoring end event for different conversation");
      return;
    }
    
    // Check if we've already handled this conversation globally (across all form instances)
    const conversationKey = state.conversationId || eventLwi;
    if (conversationKey && this._handledConversations.has(conversationKey)) {
      log.debug("conversation already handled globally, skipping", { conversationKey });
      return;
    }
    
    // v2.1 FIX: Check sessionStorage - survives form reloads unlike in-memory guards above.
    // This is the key fix for the duplicate modal on conversation form/tab close.
    if (conversationKey && SessionGuard.isHandled(conversationKey)) {
      log.debug("conversation already handled (sessionStorage), skipping", { conversationKey });
      return;
    }
    
    // Ensure data is ready (should already be cached from onLoad)
    await state.ensureReady();
    
    if (!state.conversationId) {
      log.warn("cannot open modal - no conversation ID");
      return;
    }
    
    // Mark as handled both locally and globally
    state.modalOpened = true;
    this._handledConversations.add(state.conversationId);
    
    // v2.1 FIX: Also persist to sessionStorage so it survives form reloads
    SessionGuard.markHandled(state.conversationId);
    
    // Clean up old entries after 5 minutes to prevent memory leak
    setTimeout(() => {
      this._handledConversations.delete(state.conversationId);
    }, 5 * 60 * 1000);
    
    log.debug("opening modal for conversation", { conversationId: state.conversationId });
    await ModalService.open(state);
  },
  
  _getLwiFromEvent(eventData) {
    try {
      const raw = eventData?.get?.("value");
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      return parsed?.liveWorkItemId || null;
    } catch {
      return null;
    }
  }
};

// ===== MODAL SERVICE =====
const ModalService = {
  
  async open(formState) {
    const startTime = Date.now();
    
    // Prepare data payload for custom page
    const payload = {
      summary: "",  // Summary is fetched in the modal (async)
      conversationId: formState.conversationId || "",
      workstreamId: formState.workstreamId || "",
      dispositions: formState.dispositions || [],
      version: CONFIG.VERSION
    };
    
    const pageInput = {
      pageType: "custom",
      name: CONFIG.MODAL_CUSTOM_PAGE,
      recordId: JSON.stringify(payload)
    };
    
    const navOptions = {
      target: 2,      // Dialog
      width: 850,
      height: 750,
      position: 1     // Center
    };
    
    log.debug("opening modal", { 
      conversationId: payload.conversationId,
      dispositionCount: payload.dispositions.length 
    });
    
    try {
      // navigateTo returns a promise that resolves when modal closes
      await Xrm.Navigation.navigateTo(pageInput, navOptions);
      log.perf("modal closed", startTime);
      
      // Custom Page handles all saving via Power Fx Patch
      // Refresh the form to show the new disposition codes
      log.debug("modal closed, refreshing form");
      
      // Click the Refresh command button programmatically
      try {
          
          // Try multiple selectors and contexts (Dynamics uses iframes)
          const selectors = [
            '[data-lp-id*="Refresh"]',
            '[aria-label="Refresh"]',
            'button[title="Refresh"]',
            '[data-id*="Refresh"]'
          ];
          
          // Search in current document, parent, and top window
          const contexts = [document];
          try { if (window.parent?.document) contexts.push(window.parent.document); } catch {}
          try { if (window.top?.document) contexts.push(window.top.document); } catch {}
          
          let refreshButton = null;
          let foundIn = "";
          
          for (const ctx of contexts) {
            for (const sel of selectors) {
              try {
                refreshButton = ctx.querySelector(sel);
                if (refreshButton) {
                  foundIn = ctx === document ? "document" : ctx === window.parent?.document ? "parent" : "top";
                  break;
                }
              } catch {}
            }
            if (refreshButton) break;
          }
          
        if (refreshButton) {
          refreshButton.click();
          log.debug("refresh button clicked", { foundIn, tagName: refreshButton.tagName });
        } else {
          log.warn("refresh button not found in any context");
        }
      } catch (btnErr) {
        log.warn("refresh button click failed", { error: btnErr?.message });
      }
      
    } catch (e) {
      // User may have cancelled the dialog - this is not an error
      if (e?.message?.includes("cancel") || e?.code === 1) {
        log.debug("modal cancelled by user");
      } else {
        log.error("modal open failed", { error: e?.message });
      }
      formState.modalOpened = false;  // Allow retry
      // v2.1: Do NOT unmark sessionStorage here - even if user cancels the modal,
      // we don't want it to re-fire on form close. The agent can re-trigger
      // disposition manually if needed.
    }
  }
};

// ===== MESSAGE LISTENER (optional - for future use) =====
// Custom Page handles save and shows its own success/error notifications
// This listener is kept for future extensibility if needed
const MessageHandler = {
  _registered: false,
  _formContext: null,
  
  register(formContext) {
    if (this._registered) return;
    this._formContext = formContext;
    
    window.addEventListener("message", async (evt) => {
      try {
        // Custom Page doesn't send messages back in current flow
        // But if it does in future, handle here
        if (!evt?.data || evt.data.type !== "COPILOT_DISPO_ACCEPT") return;
        
        const { disposition, dispositionValue, success } = evt.data;
        log.debug("disposition message received (optional)", { disposition, success });
        
        // Show toast if message received (optional - Custom Page already shows notification)
        if (success && formContext?.ui) {
          const msg = `✓ Disposition saved: ${dispositionValue || disposition}`;
          formContext.ui.setFormNotification(msg, "INFO", "ccaasfde_dispo_confirm");
          setTimeout(() => {
            try { formContext.ui.clearFormNotification("ccaasfde_dispo_confirm"); } catch {}
          }, 5000);
        }
        
      } catch (e) {
        log.error("message handler error", { error: e?.message });
      }
    });
    
    this._registered = true;
    log.debug("message handler registered");
  }
};

// ===== MAIN ENTRY POINT =====
async function onLoad(executionContext) {
  const formContext = executionContext.getFormContext();
  const startTime = Date.now();
  
  try {
    // Expose version for debugging
    window.top.__ccaasfdeCopilotVersion = CONFIG.VERSION;
  } catch {}
  
  log.debug("onLoad started", { version: CONFIG.VERSION });
  
  // Get or create form state
  const state = getFormState(formContext);
  
  // Register event handlers (synchronous, fast)
  CIFHandler.register(formContext);
  MessageHandler.register(formContext);
  
  // Initialize data in background (non-blocking)
  // This is fire-and-forget - the form loads instantly while data fetches in parallel
  state.initialize().then(() => {
    log.perf("background init complete", startTime);
  }).catch(e => {
    log.error("background init failed", { error: e?.message });
  });
  
  // Form loads immediately - data loading is completely non-blocking
  log.perf("onLoad complete (sync)", startTime);
}

// ===== TESTING / DEBUG UTILITIES =====
// Run from F12 console: testOpenModal()
async function testOpenModal() {
  const mockState = {
    conversationId: "test-conversation-123",
    workstreamId: "test-workstream-456",
    dispositions: [
      { id: "d1", code: "BILL_INQUIRY", label: "Billing Inquiry" },
      { id: "d2", code: "TECH_SUPPORT", label: "Technical Support" },
      { id: "d3", code: "ACCOUNT_UPDATE", label: "Account Update" }
    ]
  };
  
  await ModalService.open(mockState);
}

// Debug: View cache state
function debugCache() {
  return {
    dispositions: Object.fromEntries(GlobalCache.dispositions),
    workstreams: Object.fromEntries(GlobalCache.workstreams),
    pendingRequests: GlobalCache.pendingRequests.size
  };
}

// Debug: Clear all caches
function clearCache() {
  GlobalCache.dispositions.clear();
  GlobalCache.workstreams.clear();
  GlobalCache.pendingRequests.clear();
  log.debug("cache cleared");
}

// Export for debugging
try {
  window.__ccaasfdeCopilot = {
    version: CONFIG.VERSION,
    debugCache,
    clearCache,
    testOpenModal,
    GlobalCache,
    DataService,
    SessionGuard  // v2.1: exposed for debugging
  };
} catch {}
